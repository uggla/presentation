<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>My top 15 Rust crates</title>

    <meta name="description" content="My top 15 Rust crates" />
    <meta name="author" content="René Ribaud" />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />

    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />

    <link rel="stylesheet" href="../reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="../reveal.js/dist/theme/beige.css" />
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Sofia"> -->
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Satisfy"> -->
    <!-- <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet"> -->

    <!-- Code syntax highlighting -->
    <!-- <link rel="stylesheet" href="../reveal.js/plugin/highlight/monokai.css" /> -->
    <link rel="stylesheet" href="css/stackoverflow-light.css" />

    <style type="text/css">
      .iwantitatleft {
        text-align: left;
      }

      .longtext {
        text-align: left;
        font-size: 0.6em;
      }

      /* Larger elements */
      .lots_of_items2 ul {
        font-size: 0.7em;
        text-align: left;
      }

      /* Smaller elements */
      .lots_of_items3 ul {
        font-size: 0.55em;
        text-align: left;
      }

      .lots_of_items3 ul ul {
        font-size: 0.8em;
        text-align: left;
      }

      .lots_of_items3 table {
        font-size: 0.8em;
        float: left;
        margin-right: 1em;
      }

      /* Larger elements */
      .lots_of_items4 ul {
        font-size: 0.8em;
        text-align: left;
      }

      /* Normal elements */
      .lots_of_items ul {
        font-size: 0.6em;
        text-align: left;
      }

      .lots_of_items ul ul {
        font-size: 0.8em;
        text-align: left;
      }

      .lots_of_items h3 {
        font-size: 0.7em;
      }

      .lots_of_items h4 {
        font-size: 0.6em;
      }

      .lots_of_items code {
        font-size: 0.7em;
      }

      .lots_of_items table {
        float: left;
        margin-right: 1em;
      }

      .clearfix {
        clear: left;
      }

      .long_link a {
        font-size: 0.8em;
      }

      .pic {
        position: relative;
        float: left;
        width: 50%;
        top: 0px;
      }

      /* Remove image margin use in conjuction with .pic */
      .no_margin img {
        margin: 0px;
      }

      .left_text {
        position: relative;
        float: left;
        width: 50%;
        text-align: left;
      }

      .left_text_bio {
        position: relative;
        float: left;
        width: 50%;
        font-size: 0.6em;
        text-align: left;
      }

      .right_text {
        width: 50%;
        text-align: left;
        float: right;
        text-align: left;
      }

      .skill-list li {
        font-size: 1.5rem;
        margin-top: 1rem;
      }
      /*
            .reveal a { color: #007DBA; }
            .reveal h2 b { color: #0096D6; }
            .reveal h2 .day { font-size: 0.6em; position:relative; bottom: 20px; }
            .reveal { font-family: "Source Code Pro", "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans,sans-serif; font-size:40px; }
            */
      .reveal {
        font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans,
          sans-serif;
        font-size: 40px;
      }

      .reveal h2 {
        margin-top: 35px;
      }

      .reveal ul {
        margin: 0 0 0 0;
      }

      .reveal pre {
        width: 100%;
        font-size: 18px;
      }

      .reveal pre code {
        max-height: 100%;
      }

      .reveal section img {
        border: none;
        box-shadow: none;
        background: rgba(255, 255, 255, 0);
      }

      body {
        line-height: 1.1;
      }
    </style>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <!-- <section data-background="images/background.svg" data-background-size="cover"> -->
        <section>
          <h2>My top 15</h2>
          <h1>Rust crates</h1>
          <img src="images/crates.gif" alt="crates" width="60%" />
        </section>

        <section>
          <h3>2 words about me</h3>
          <div class="left_text_bio">
            <!-- <pre class="bio"> -->
            <ul>
              <li>Stats</li>
              <ul>
                <li>First name: René (Uggla)</li>
                <li>Last name: Ribaud</li>
              </ul>
            </ul>

            <ul>
              <li>Skills</li>
              <ul>
                <li>Class: Software engineer</li>
                <li>Previous Class: Solution architect (Cloud / Devops)</li>
                <li>Latest Guilde: Red Hat</li>
                <li>Game start: 1998</li>
                <li>Preferred weapons: Rust / Python</li>
                <li>Artefact: Openstack Nova</li>
              </ul>
            </ul>

            <ul>
              <li>Optional traits</li>
              <ul>
                <li>Linux and FLOSS since 1995</li>
                <li>Previously Ops, Dev today to produce my own bugs</li>
                <li>Rust coding dojo with AlpesCraft</li>
              </ul>
            </ul>
          </div>
          <div class="pic">
            <img src="images/uggla.png" alt="uggla" width="100%" />
          </div>
        </section>

        <section>
          <h3>About This Selection</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                This top 15 represents <strong>my favorite Rust crates</strong>,
                the ones I use or have used in my projects.
              </li>
              <li>
                <em>Note:</em> There are often other alternatives for similar
                use cases. This ranking therefore reflects
                <strong>my personal preferences</strong>, based on my experience
                and specific needs.
              </li>
              <li>
                This is focused on crates, excluding frameworks (e.g., Actix)
                and tools (e.g., Bindgen).
              </li>
              <li>
                Please <strong>don’t blame me</strong> if your favorite crate is
                not included in the list. We can share them afterward!
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Serde</h3>
          <img src="images/spongebob-magic.gif" alt="magic" width="75%" />
        </section>

        <section>
          <h3>Serde 1/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                Serde is a magical framework for serializing and deserializing
                Rust data structures into JSON, TOML, YAML, and more.
              </li>
              <li>
                Format supported by compagnion crates: serde_json, bincode...
              </li>
              <li>
                It is as simple as:
                <ol>
                  <li>Deriving a struct.</li>
                  <li>Converting to and from strings.</li>
                </ol>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Serde 2/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use serde::{Serialize, Deserialize};

                  #[derive(Serialize, Deserialize, Debug)]
                  struct User {
                      id: u32,
                      name: String,
                      email: String,
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Serde 3/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  fn main() {
                      // Sérialisation : Rust → JSON
                      let user = User {
                          id: 1,
                          name: "Alice".to_string(),
                          email: "alice@example.com".to_string(),
                      };
                      let json = serde_json::to_string(&user).unwrap();
                      println!("JSON: {}", json);

                      // Désérialisation : JSON → Rust
                      let json_str = r#"
                          {
                              "id": 2,
                              "name": "Bob",
                              "email": "bob@example.com"
                          }
                      "#;
                      let deserialized_user: User = serde_json::from_str(json_str).unwrap();
                      println!("User: {:?}", deserialized_user);
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Clap</h3>
          <img src="images/clap.gif" alt="clap" width="50%" />
        </section>

        <section>
          <h3>Clap 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>Already well covered in a previous meetup.</li>
              <li>Parse CLI arguments an options.</li>
              <li>
                Derive feature allow to define arguments and options from a
                struct.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Clap 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use clap::Parser;

                  /// Simple CLI tool example
                  #[derive(Parser, Debug)]
                  #[command(name = "greet")]
                  #[command(about = "A simple program to greet someone", long_about = None)]
                  struct Args {
                      /// The name of the person to greet
                      #[arg(short, long)]
                      name: String,

                      /// Number of times to print the greeting
                      #[arg(short, long, default_value_t = 1)]
                      count: u8,
                  }

                  fn main() {
                      let args = Args::parse();

                      for _ in 0..args.count {
                          println!("Hello, {}!", args.name);
                      }
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Thiserror / Anyhow</h3>
          <img src="images/error.gif" alt="error" width="50%" />
        </section>

        <section>
          <h3>Thiserror / Anyhow 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>Already well covered in a previous meetup.</li>
              <li>
                Thiserror:
                <ul>
                  <li>
                    Provides an ergonomic way to define custom error types in
                    Rust.
                  </li>
                  <li>
                    Automatically implements the
                    <code>std::error::Error</code> trait for your errors.
                  </li>
                  <li>
                    Best suited for libraries where structured error types are
                    needed.
                  </li>
                </ul>
              </li>

              <li>
                Anyhow
                <ul>
                  <li>
                    Simplifies error handling for applications (not libraries).
                  </li>
                  <li>
                    Offers a generic error type <code>anyhow::Error</code> to
                    encapsulate any error.
                  </li>
                  <li>
                    Perfect for applications that don't need precise error
                    typing.
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Thiserror / Anyhow 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use anyhow::{Context};
                  use thiserror::Error;

                  #[derive(Error, Debug)]
                  enum MyError {
                      #[error("Configuration file not found: {0}")]
                      ConfigNotFound(String),

                      #[error("Invalid input: {0}")]
                      InvalidInput(String),
                  }

                  fn read_config(file: &str) -> Result&lt;String, MyError&gt; {
                      if file == "missing.conf" {
                          return Err(MyError::ConfigNotFound(file.to_string()).into());
                      }
                      if file == "invalid.conf" {
                          return Err(MyError::InvalidInput("Invalid syntax".to_string()).into());
                      }
                      Ok("config content".to_string())
                  }

                  fn main() -> anyhow::Result&lt;()&gt;{
                      let config =
                          read_config("missing.conf").with_context(|| "Failed to load the configuration file")?;
                      println!("Config: {}", config);
                      Ok(())
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Nom</h2>
          <img src="images/om-nom.gif" alt="nom" width="50%" />
        </section>

        <section>
          <h3>Nom 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>Nom is a parser combinators library.</li>
              <li>It is like regexp on steroids and more readable.</li>
              <li>It can work on complete strings or streams.</li>
              <li>
                The regexp library is great too, but to my mind, nom help to
                write more maintainable code.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Nom 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  #[derive(Debug,PartialEq)]
                  pub struct Color { pub red:   u8, pub green: u8, pub blue:  u8, }

                  fn from_hex(input: &str) -> Result&lt;u8, std::num::ParseIntError&gt; {
                    u8::from_str_radix(input, 16)
                  }

                  fn is_hex_digit(c: char) -> bool {
                    c.is_digit(16)
                  }

                  fn hex_primary(input: &str) -> IResult&lt;&str, u8&gt; {
                    map_res(
                      take_while_m_n(2, 2, is_hex_digit),
                      from_hex
                    )(input)
                  }

                  fn hex_color(input: &str) -> IResult&lt;&str, Color&gt; {
                    let (input, _) = tag("#")(input)?;
                    let (input, (red, green, blue)) = tuple((hex_primary, hex_primary, hex_primary))(input)?;

                    Ok((input, Color { red, green, blue }))
                  }

                  #[test]
                  fn parse_color() {
                    assert_eq!(hex_color("#2F14DF"), Ok(("", Color { red: 47, green: 20, blue: 223, })));
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Rayon</h2>
          <img src="images/deathstar-rayon.gif" alt="rayon" width="75%" />
        </section>

        <section>
          <h3>Rayon 1/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>Data parallelism library.</li>
              <li>
                Provides a lot of parallel iterators for various types.
                <ul>
                  <li>Vec</li>
                  <li>Array</li>
                  <li>Ranges</li>
                  <li>Collections</li>
                  <