<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>My top 15 Rust crates</title>

    <meta name="description" content="My top 15 Rust crates" />
    <meta name="author" content="René Ribaud" />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />

    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />

    <link rel="stylesheet" href="../reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="../reveal.js/dist/theme/beige.css" />
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Sofia"> -->
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Satisfy"> -->
    <!-- <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet"> -->

    <!-- Code syntax highlighting -->
    <!-- <link rel="stylesheet" href="../reveal.js/plugin/highlight/monokai.css" /> -->
    <link rel="stylesheet" href="css/stackoverflow-light.css" />

    <style type="text/css">
      .iwantitatleft {
        text-align: left;
      }

      .longtext {
        text-align: left;
        font-size: 0.6em;
      }

      /* Larger elements */
      .lots_of_items2 ul {
        font-size: 0.7em;
        text-align: left;
      }

      /* Smaller elements */
      .lots_of_items3 ul {
        font-size: 0.55em;
        text-align: left;
      }

      .lots_of_items3 ul ul {
        font-size: 0.8em;
        text-align: left;
      }

      .lots_of_items3 table {
        font-size: 0.8em;
        float: left;
        margin-right: 1em;
      }

      /* Larger elements */
      .lots_of_items4 ul {
        font-size: 0.8em;
        text-align: left;
      }

      /* Normal elements */
      .lots_of_items ul {
        font-size: 0.6em;
        text-align: left;
      }

      .lots_of_items ul ul {
        font-size: 0.8em;
        text-align: left;
      }

      .lots_of_items h3 {
        font-size: 0.7em;
      }

      .lots_of_items h4 {
        font-size: 0.6em;
      }

      .lots_of_items code {
        font-size: 0.7em;
      }

      .lots_of_items table {
        float: left;
        margin-right: 1em;
      }

      .clearfix {
        clear: left;
      }

      .long_link a {
        font-size: 0.8em;
      }

      .pic {
        position: relative;
        float: left;
        width: 50%;
        top: 0px;
      }

      /* Remove image margin use in conjuction with .pic */
      .no_margin img {
        margin: 0px;
      }

      .left_text {
        position: relative;
        float: left;
        width: 50%;
        text-align: left;
      }

      .left_text_bio {
        position: relative;
        float: left;
        width: 50%;
        font-size: 0.6em;
        text-align: left;
      }

      .right_text {
        width: 50%;
        text-align: left;
        float: right;
        text-align: left;
      }

      .skill-list li {
        font-size: 1.5rem;
        margin-top: 1rem;
      }
      /*
            .reveal a { color: #007DBA; }
            .reveal h2 b { color: #0096D6; }
            .reveal h2 .day { font-size: 0.6em; position:relative; bottom: 20px; }
            .reveal { font-family: "Source Code Pro", "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans,sans-serif; font-size:40px; }
            */
      .reveal {
        font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans,
          sans-serif;
        font-size: 40px;
      }

      .reveal h2 {
        margin-top: 35px;
      }

      .reveal ul {
        margin: 0 0 0 0;
      }

      .reveal pre {
        width: 100%;
        font-size: 18px;
      }

      .reveal pre code {
        max-height: 100%;
      }

      .reveal section img {
        border: none;
        box-shadow: none;
        background: rgba(255, 255, 255, 0);
      }

      body {
        line-height: 1.1;
      }
    </style>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <!-- <section data-background="images/background.svg" data-background-size="cover"> -->
        <section>
          <h2>My top 15</h2>
          <h1>Rust crates</h1>
          <img src="images/crates.gif" alt="crates" width="60%" />
        </section>

        <section>
          <h3>2 words about me</h3>
          <div class="left_text_bio">
            <!-- <pre class="bio"> -->
            <ul>
              <li>Stats</li>
              <ul>
                <li>First name: René (Uggla)</li>
                <li>Last name: Ribaud</li>
              </ul>
            </ul>

            <ul>
              <li>Skills</li>
              <ul>
                <li>Class: Software engineer</li>
                <li>Previous Class: Solution architect (Cloud / Devops)</li>
                <li>Latest Guilde: Red Hat</li>
                <li>Game start: 1998</li>
                <li>Preferred weapons: Rust / Python</li>
                <li>Artefact: Openstack Nova</li>
              </ul>
            </ul>

            <ul>
              <li>Optional traits</li>
              <ul>
                <li>Linux and FLOSS since 1995</li>
                <li>Previously Ops, Dev today to produce my own bugs</li>
                <li>Rust coding dojo with AlpesCraft</li>
              </ul>
            </ul>
          </div>
          <div class="pic">
            <img src="images/uggla.png" alt="uggla" width="100%" />
          </div>
        </section>

        <section>
          <h3>About This Selection</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                This top 15 represents <strong>my favorite Rust crates</strong>,
                the ones I use or have used in my projects.
              </li>
              <li>
                <em>Note:</em> There are often other alternatives for similar
                use cases. This ranking therefore reflects
                <strong>my personal preferences</strong>, based on my experience
                and specific needs.
              </li>
              <li>
                This is focused on crates, excluding frameworks (e.g., Actix)
                and tools (e.g., Bindgen).
              </li>
              <li>
                Please <strong>don’t blame me</strong> if your favorite crate is
                not included in the list. We can share them afterward!
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Serde</h3>
          <img src="images/spongebob-magic.gif" alt="magic" width="75%" />
        </section>

        <section>
          <h3>Serde 1/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                Serde is a magical framework for serializing and deserializing
                Rust data structures into JSON, TOML, YAML, and more.
              </li>
              <li>
                Format supported by compagnion crates: serde_json, bincode...
              </li>
              <li>
                It is as simple as:
                <ol>
                  <li>Deriving a struct.</li>
                  <li>Converting to and from strings.</li>
                </ol>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Serde 2/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use serde::{Serialize, Deserialize};

                  #[derive(Serialize, Deserialize, Debug)]
                  struct User {
                      id: u32,
                      name: String,
                      email: String,
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Serde 3/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  fn main() {
                      // Sérialisation : Rust → JSON
                      let user = User {
                          id: 1,
                          name: "Alice".to_string(),
                          email: "alice@example.com".to_string(),
                      };
                      let json = serde_json::to_string(&user).unwrap();
                      println!("JSON: {}", json);

                      // Désérialisation : JSON → Rust
                      let json_str = r#"
                          {
                              "id": 2,
                              "name": "Bob",
                              "email": "bob@example.com"
                          }
                      "#;
                      let deserialized_user: User = serde_json::from_str(json_str).unwrap();
                      println!("User: {:?}", deserialized_user);
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Clap</h3>
          <img src="images/clap.gif" alt="clap" width="50%" />
        </section>

        <section>
          <h3>Clap 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>Already well covered in a previous meetup.</li>
              <li>Parse CLI arguments an options.</li>
              <li>
                Derive feature allow to define arguments and options from a
                struct.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Clap 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use clap::Parser;

                  /// Simple CLI tool example
                  #[derive(Parser, Debug)]
                  #[command(name = "greet")]
                  #[command(about = "A simple program to greet someone", long_about = None)]
                  struct Args {
                      /// The name of the person to greet
                      #[arg(short, long)]
                      name: String,

                      /// Number of times to print the greeting
                      #[arg(short, long, default_value_t = 1)]
                      count: u8,
                  }

                  fn main() {
                      let args = Args::parse();

                      for _ in 0..args.count {
                          println!("Hello, {}!", args.name);
                      }
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Thiserror / Anyhow</h3>
          <img src="images/error.gif" alt="error" width="50%" />
        </section>

        <section>
          <h3>Thiserror / Anyhow 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>Already well covered in a previous meetup.</li>
              <li>
                Thiserror:
                <ul>
                  <li>
                    Provides an ergonomic way to define custom error types in
                    Rust.
                  </li>
                  <li>
                    Automatically implements the
                    <code>std::error::Error</code> trait for your errors.
                  </li>
                  <li>
                    Best suited for libraries where structured error types are
                    needed.
                  </li>
                </ul>
              </li>

              <li>
                Anyhow
                <ul>
                  <li>
                    Simplifies error handling for applications (not libraries).
                  </li>
                  <li>
                    Offers a generic error type <code>anyhow::Error</code> to
                    encapsulate any error.
                  </li>
                  <li>
                    Perfect for applications that don't need precise error
                    typing.
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Thiserror / Anyhow 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use anyhow::{Context};
                  use thiserror::Error;

                  #[derive(Error, Debug)]
                  enum MyError {
                      #[error("Configuration file not found: {0}")]
                      ConfigNotFound(String),

                      #[error("Invalid input: {0}")]
                      InvalidInput(String),
                  }

                  fn read_config(file: &str) -> Result&lt;String, MyError&gt; {
                      if file == "missing.conf" {
                          return Err(MyError::ConfigNotFound(file.to_string()).into());
                      }
                      if file == "invalid.conf" {
                          return Err(MyError::InvalidInput("Invalid syntax".to_string()).into());
                      }
                      Ok("config content".to_string())
                  }

                  fn main() -> anyhow::Result&lt;()&gt;{
                      let config =
                          read_config("missing.conf").with_context(|| "Failed to load the configuration file")?;
                      println!("Config: {}", config);
                      Ok(())
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Nom</h2>
          <img src="images/om-nom.gif" alt="nom" width="50%" />
        </section>

        <section>
          <h3>Nom 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>Nom is a parser combinators library.</li>
              <li>It is like regexp on steroids and more readable.</li>
              <li>It can work on complete strings or streams.</li>
              <li>
                The regexp library is great too, but to my mind, nom help to
                write more maintainable code.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Nom 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  #[derive(Debug,PartialEq)]
                  pub struct Color { pub red:   u8, pub green: u8, pub blue:  u8, }

                  fn from_hex(input: &str) -> Result&lt;u8, std::num::ParseIntError&gt; {
                    u8::from_str_radix(input, 16)
                  }

                  fn is_hex_digit(c: char) -> bool {
                    c.is_digit(16)
                  }

                  fn hex_primary(input: &str) -> IResult&lt;&str, u8&gt; {
                    map_res(
                      take_while_m_n(2, 2, is_hex_digit),
                      from_hex
                    )(input)
                  }

                  fn hex_color(input: &str) -> IResult&lt;&str, Color&gt; {
                    let (input, _) = tag("#")(input)?;
                    let (input, (red, green, blue)) = tuple((hex_primary, hex_primary, hex_primary))(input)?;

                    Ok((input, Color { red, green, blue }))
                  }

                  #[test]
                  fn parse_color() {
                    assert_eq!(hex_color("#2F14DF"), Ok(("", Color { red: 47, green: 20, blue: 223, })));
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Rayon</h2>
          <img src="images/deathstar-rayon.gif" alt="rayon" width="75%" />
        </section>

        <section>
          <h3>Rayon 1/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>Data parallelism library.</li>
              <li>
                Provides a lot of parallel iterators for various types.
                <ul>
                  <li>Vec</li>
                  <li>Array</li>
                  <li>Ranges</li>
                  <li>Collections</li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                Simply changing an iterator fror iter to par_iter can
                parallelize it.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Rayon 2/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use rayon::prelude::*;

                  /// Check if a number is prime
                  fn is_prime(n: u64) -> bool {
                      if n < 2 {
                          return false;
                      }
                      for i in 2..=((n as f64).sqrt() as u64) {
                          if n % i == 0 {
                              return false;
                          }
                      }
                      true
                  }

                  /// Generate prime numbers up to a given limit
                  fn generate_primes(limit: u64) -> Vec&lt;u64&gt; {
                      (2..=limit) // Create a range from 2 to the limit
                          .into_par_iter() // Convert to a parallel iterator using rayon
                          .filter(|&n| is_prime(n)) // Filter out non-prime numbers
                          .collect() // Collect results into a vector
                  }

                  fn main() {
                      let limit = 20_000_000; // Upper limit for prime numbers
                      let primes = generate_primes(limit);

                      println!("Found {} primes up to {}.", primes.len(), limit);
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Rayon 3/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs bash" data-trim>
                 🦉 uggla   main  ~  workspace  rust  prime  hyperfine target/release/prime_not_par target/release/prime
                Benchmark 1: target/release/prime_not_par
                  Time (mean ± σ):     13.349 s ±  0.793 s    [User: 13.276 s, System: 0.014 s]
                  Range (min … max):   12.411 s … 14.910 s    10 runs

                Benchmark 2: target/release/prime
                  Time (mean ± σ):      3.523 s ±  0.279 s    [User: 24.565 s, System: 0.062 s]
                  Range (min … max):    3.284 s …  4.236 s    10 runs

                Summary
                  target/release/prime ran
                    3.79 ± 0.38 times faster than target/release/prime_not_par
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Itertools</h2>
          <img src="images/itertools.gif" alt="itertool" width="75%" />
        </section>

        <section>
          <h3>Itertools 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                Itertools is a powerful crate providing additional iterator
                adaptors and utilities for Rust.
              </li>
              <li>
                Extends the standard Iterator with a wide range of combinators
                for advanced data processing.
              </li>
              <li>
                Sort, join, cartesian product, permutations, combinations,
                group_by, ...
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Itertools 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  #[derive(Debug,PartialEq)]
                  use itertools::Itertools;

                  fn main() {
                      let nums = vec![3, 2, 1];

                    // Sort and join elements into a string
                      let joined = nums.iter().sorted().join(",");
                      assert_eq!("1,2,3", joined);

                      // Generate all combinations of size 2
                      let combinations: Vec&ltVec&ltusize&gt&gt = nums.into_iter().combinations(2).collect();
                      assert_eq!(vec![vec![3,2], vec![3,1],vec![2,1]], combinations);

                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Minreq</h2>
          <img src="images/minreq.gif" alt="minreq" width="75%" />
        </section>

        <section>
          <h3>Minreq 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>Simple, minimal-dependency HTTP client.</li>
              <li>Lightweight.</li>
              <li>Only sync.</li>
              <li>Serde integration.</li>
              <li>TLS support.</li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Minreq 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  fn main() -> Result<(), minreq::Error> {
                      let response = minreq::post("http://httpbin.org/anything")
                          .with_body("Hello, world!")
                          .send()?;

                      // httpbin.org/anything returns the body in the json field "data":
                      let json: serde_json::Value = response.json()?;
                      assert_eq!("Hello, world!", json["data"]);

                      Ok(())
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Ordered-float</h3>
          <img src="images/ordered-float.gif" alt="ordered-float" width="75%" />
        </section>

        <section>
          <h3>Ordered-float 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                Floating-point numbers (<code>f32</code>, <code>f64</code>)
                cannot be directly used as keys in structures like
                <code>HashSet</code> or <code>HashMap</code>. This is because
                they do not implement necessary traits (<code>Eq</code> and
                <code>Hash</code>) due to special behaviors (e.g.,
                <code>NaN</code>).
              </li>
            </ul>

            <ul>
              <li>
                Ordered-float provides a wrapper around floating-point types,
                making them orderable and usable in collections.
              </li>
              <ul>
                <li>
                  Ensures consistent comparisons, handling edge cases like
                  <code>-0.0</code> and <code>0.0</code> as equal, and placing
                  <code>NaN</code> consistently during sorting.
                </li>
                <li>
                  Values are sorted consistently, even with edge cases like
                  <code>-0.0</code> and <code>NaN</code>.
                </li>
                <li>
                  <code>HashSet</code> ignores duplicates and treats
                  <code>-0.0</code> and <code>0.0</code> as identical.
                </li>
              </ul>
              <li>
                Solves the problem where standard floating-point numbers cannot
                be used in such structures.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Ordered-float 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use ordered_float::OrderedFloat;
                  use std::collections::HashSet;

                  fn main() {
                      // Exemple 1 : Tri de nombres flottants
                      let mut floats = vec![3.2, 1.5, 2.8, 4.1, -0.0, 0.0, f64::NAN];
                      //floats.sort_by(|a,b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
                      floats.sort_by_key(|&x| OrderedFloat(x)); // Tri avec OrderedFloat

                      println!("Sorted floats: {:?}", floats);

                      // Exemple 2 : Utilisation dans un HashSet
                      let mut set: HashSet&ltOrderedFloat&ltf64&gt&gt = HashSet::new();
                      set.insert(OrderedFloat(3.2));
                      set.insert(OrderedFloat(1.5));
                      set.insert(OrderedFloat(1.5)); // Duplicate, ne sera pas ajouté
                      set.insert(OrderedFloat(-0.0)); // -0.0 et 0.0 sont considérés égaux
                      set.insert(OrderedFloat(0.0));

                      println!("HashSet contains: {:?}", set);
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Indicatif</h2>
          <img src="images/indicatif.gif" alt="indicatif" width="50%" />
        </section>

        <section>
          <h3>Indicatif 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                Floating-point numbers (<code>f32</code>, <code>f64</code>)
                cannot be directly used as keys in structures like
                <code>HashSet</code> or <code>HashMap</code>. This is because
                they do not implement necessary traits (<code>Eq</code> and
                <code>Hash</code>) due to special behaviors (e.g.,
                <code>NaN</code>).
              </li>
            </ul>

            <ul>
              <li>
                Ordered-float provides a wrapper around floating-point types,
                making them orderable and usable in collections.
              </li>
              <ul>
                <li>
                  Ensures consistent comparisons, handling edge cases like
                  <code>-0.0</code> and <code>0.0</code> as equal, and placing
                  <code>NaN</code> consistently during sorting.
                </li>
                <li>
                  Values are sorted consistently, even with edge cases like
                  <code>-0.0</code> and <code>NaN</code>.
                </li>
                <li>
                  <code>HashSet</code> ignores duplicates and treats
                  <code>-0.0</code> and <code>0.0</code> as identical.
                </li>
              </ul>
              <li>
                Solves the problem where standard floating-point numbers cannot
                be used in such structures.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Indicatif 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use ordered_float::OrderedFloat;
                  use std::collections::HashSet;

                  fn main() {
                      // Exemple 1 : Tri de nombres flottants
                      let mut floats = vec![3.2, 1.5, 2.8, 4.1, -0.0, 0.0, f64::NAN];
                      //floats.sort_by(|a,b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
                      floats.sort_by_key(|&x| OrderedFloat(x)); // Tri avec OrderedFloat

                      println!("Sorted floats: {:?}", floats);

                      // Exemple 2 : Utilisation dans un HashSet
                      let mut set: HashSet&ltOrderedFloat&ltf64&gt&gt = HashSet::new();
                      set.insert(OrderedFloat(3.2));
                      set.insert(OrderedFloat(1.5));
                      set.insert(OrderedFloat(1.5)); // Duplicate, ne sera pas ajouté
                      set.insert(OrderedFloat(-0.0)); // -0.0 et 0.0 sont considérés égaux
                      set.insert(OrderedFloat(0.0));

                      println!("HashSet contains: {:?}", set);
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Pyo3</h2>
          <img src="images/space_invaders.png" alt="ecs" width="75%" />
        </section>

        <section>
          <h2>Rustls</h2>
          <img src="images/space_invaders.png" alt="ecs" width="75%" />
        </section>

        <section>
          <h2>Tungstenite</h2>
          <img src="images/space_invaders.png" alt="ecs" width="75%" />
        </section>

        <section>
          <h2>Rstest</h2>
          <img src="images/space_invaders.png" alt="ecs" width="75%" />
        </section>

        <section>
          <h2>Raqote</h2>
          <img src="images/space_invaders.png" alt="ecs" width="75%" />
        </section>

        <section>
          <h2>Log / Simplelogger</h2>
          <img src="images/space_invaders.png" alt="ecs" width="75%" />
        </section>

        <section>
          <h2>What are you using ?</h2>
          <img src="images/space_invaders.png" alt="ecs" width="75%" />
        </section>

        <section>
          <h2>Blessed</h2>
          <img src="images/space_invaders.png" alt="ecs" width="75%" />
        </section>

        <section>
          <h2>Thanks</h2>
          <img src="images/thanks.gif" alt="thank_you" width="50%" />
          <ul>
            <li>René Ribaud &lt;rene.ribaud@gmail.com&gt;</li>
          </ul>
        </section>
      </div>
    </div>

    <script type="module">
      import Reveal from "../reveal.js/dist/reveal.esm.js";
      import Markdown from "../reveal.js/plugin/markdown/markdown.esm.js";
      import Notes from "../reveal.js/plugin/notes/notes.esm.js";
      import Highlight from "../reveal.js/plugin/highlight/highlight.esm.js";
      import Zoom from "../reveal.js/plugin/zoom/zoom.esm.js";

      let deck = new Reveal({
        plugins: [Markdown, Notes, Highlight, Zoom],
        controls: true,
        progress: true,
        history: true,
        center: false,
        width: 960,
        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,
        // Use this to print in pdf
        // margin: 0.6,

        // Bounds for smallest/largest possible scale to apply to content
        minScale: 0.2,
        maxScale: 1.5,

        transition: "convex",
      });

      deck.initialize();
    </script>
  </body>
</html>
