<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>An Initial Collection of Rust Crates</title>

    <meta name="description" content="An Initial Collection of Rust Crates" />
    <meta name="author" content="René Ribaud" />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />

    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"
    />

    <link rel="stylesheet" href="../reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="../reveal.js/dist/theme/beige.css" />
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Sofia"> -->
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Satisfy"> -->
    <!-- <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet"> -->

    <!-- Code syntax highlighting -->
    <!-- <link rel="stylesheet" href="../reveal.js/plugin/highlight/monokai.css" /> -->
    <link rel="stylesheet" href="css/stackoverflow-light.css" />

    <style type="text/css">
      .iwantitatleft {
        text-align: left;
      }

      .longtext {
        text-align: left;
        font-size: 0.6em;
      }

      /* Larger elements */
      .lots_of_items2 ul {
        font-size: 0.7em;
        text-align: left;
      }

      /* Smaller elements */
      .lots_of_items3 ul {
        font-size: 0.55em;
        text-align: left;
      }

      .lots_of_items3 ul ul {
        font-size: 0.8em;
        text-align: left;
      }

      .lots_of_items3 table {
        font-size: 0.8em;
        float: left;
        margin-right: 1em;
      }

      /* Larger elements */
      .lots_of_items4 ul {
        font-size: 0.8em;
        text-align: left;
      }

      /* Normal elements */
      .lots_of_items ul {
        font-size: 0.6em;
        text-align: left;
      }

      .lots_of_items ul ul {
        font-size: 0.8em;
        text-align: left;
      }

      .lots_of_items h3 {
        font-size: 0.7em;
      }

      .lots_of_items h4 {
        font-size: 0.6em;
      }

      .lots_of_items code {
        font-size: 0.7em;
      }

      .lots_of_items table {
        float: left;
        margin-right: 1em;
      }

      .clearfix {
        clear: left;
      }

      .long_link a {
        font-size: 0.8em;
      }

      .pic {
        position: relative;
        float: left;
        width: 50%;
        top: 0px;
      }

      /* Remove image margin use in conjuction with .pic */
      .no_margin img {
        margin: 0px;
      }

      .left_text {
        position: relative;
        float: left;
        width: 50%;
        text-align: left;
      }

      .left_text_bio {
        position: relative;
        float: left;
        width: 50%;
        font-size: 0.6em;
        text-align: left;
      }

      .right_text {
        width: 50%;
        text-align: left;
        float: right;
        text-align: left;
      }

      .skill-list li {
        font-size: 1.5rem;
        margin-top: 1rem;
      }
      /*
            .reveal a { color: #007DBA; }
            .reveal h2 b { color: #0096D6; }
            .reveal h2 .day { font-size: 0.6em; position:relative; bottom: 20px; }
            .reveal { font-family: "Source Code Pro", "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans,sans-serif; font-size:40px; }
            */
      .reveal {
        font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans,
          sans-serif;
        font-size: 40px;
      }

      .reveal h2 {
        margin-top: 35px;
      }

      .reveal ul {
        margin: 0 0 0 0;
      }

      .reveal pre {
        width: 100%;
        font-size: 18px;
      }

      .reveal pre code {
        max-height: 100%;
      }

      .reveal section img {
        border: none;
        box-shadow: none;
        background: rgba(255, 255, 255, 0);
      }

      body {
        line-height: 1.1;
      }
    </style>
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <!-- <section data-background="images/background.svg" data-background-size="cover"> -->
        <section>
          <h2>An Initial Collection of</h2>
          <h1>Rust crates</h1>
          <img src="images/crates.gif" alt="crates" width="60%" />
        </section>

        <section>
          <h3>2 words about me</h3>
          <div class="left_text_bio">
            <!-- <pre class="bio"> -->
            <ul>
              <li>Stats</li>
              <ul>
                <li>First name: René (Uggla)</li>
                <li>Last name: Ribaud</li>
              </ul>
            </ul>

            <ul>
              <li>Skills</li>
              <ul>
                <li>Class: Software engineer</li>
                <li>Previous Class: Solution architect (Cloud / Devops)</li>
                <li>Latest Guilde: Red Hat</li>
                <li>Game start: 1998</li>
                <li>Preferred weapons: Rust / Python</li>
                <li>Artefact: Openstack Nova</li>
              </ul>
            </ul>

            <ul>
              <li>Optional traits</li>
              <ul>
                <li>Linux and FLOSS since 1995</li>
                <li>Previously Ops, Dev today to produce my own bugs</li>
                <li>Rust coding dojo with AlpesCraft</li>
              </ul>
            </ul>
          </div>
          <div class="pic">
            <img src="images/uggla.png" alt="uggla" width="100%" />
          </div>
          <audio controls>
            <source src="sounds/mgs.mp3" type="audio/mpeg" />
            Your browser does not support the audio element.
          </audio>
        </section>

        <section>
          <h3>A Quite Small Standard Library</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                Rust's deliberate choice to keep the standard library small:
                <ul>
                  <li>Ensures easier compatibility across platforms.</li>
                  <li>
                    Allows code to mature as external crates before potential
                    inclusion in the standard library.
                  </li>
                  <li>
                    Promotes innovation by allowing multiple competing solutions
                    in the ecosystem.
                  </li>
                </ul>
              </li>
              <li>
                As a result, you need to familiarize yourself with the Rust
                ecosystem to find the right crates for your needs.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>About This Selection</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                This selection represents
                <strong>some of my favorite Rust crates</strong>, the ones I use
                or have used in my projects.
              </li>
              <li>
                <em>Note:</em> There are often other alternatives for similar
                use cases. This selection therefore reflects
                <strong>my personal preferences</strong>, based on my experience
                and specific needs.
              </li>
              <li>
                This is focused on "simple" crates, excluding frameworks (e.g.,
                Actix) and tools (e.g., Bindgen).
              </li>
              <li>
                Please <strong>don’t blame me</strong> if your favorite crate is
                not included in the list. We can share them afterward!
              </li>
              <li>
                It wasn't easy to make this selection, as there are many other
                interesting crates that could have been included. If you enjoy
                this presentation, I would be happy to showcase additional
                crates in the future.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>How to Use a Crate? 1/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                Add the crate name to the dependencies section of your
                <code>Cargo.toml</code>:
                <pre>
                  <code class="hljs toml" data-trim>
                    ───────┬──────────────────────────────────────────────
                           │ File: Cargo.toml
                    ───────┼──────────────────────────────────────────────
                       1   │ [package]
                       2   │ name = "rand_example"
                       3   │ version = "0.1.0"
                       4   │ edition = "2021"
                       5   │
                       6   │ [dependencies]
                       7   │ rand = "0.8.5"
                    ───────┴──────────────────────────────────────────────
                  </code>
                </pre>
              </li>
              <li>
                Add the namespace of the crate using the
                <code>use</code> statement.
              </li>
              <li>
                Depending on your crate:
                <ul>
                  <li>
                    You might use a <strong>prelude</strong> to import common
                    public items.
                    <pre>
                    <code class="hljs rust" data-trim>
                      use bevy::prelude::*;
                    </code>
                  </pre>
                  </li>
                  <li>You can import specific items explicitly if needed:</li>
                  <pre>
                    <code class="hljs rust" data-trim>
                      use rand::thread_rng;
                      use rand::distributions::Uniform;
                    </code>
                  </pre>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>How to Use a Crate? 2/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                A crate might have features. This is useful for:
                <ul>
                  <li>
                    Compatibility, e.g., targeting specific operating systems.
                  </li>
                  <li>
                    Technology choice, e.g., selecting between OpenSSL and
                    Rustls.
                  </li>
                  <li>
                    Reducing compilation time by enabling only the necessary
                    functionality.
                  </li>
                </ul>

                <pre>
                  <code class="hljs toml" data-trim>
                    6   │ [dependencies]
                    7   │ rand = { version = "0.8.5", features = ["simd_support"] }
                  </code>
                </pre>
              </li>
              <li>
                A <code>Cargo.lock</code> is created to track dependencies.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>How to Use a Crate? 3/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                Before Rust 1.62, a Cargo plugin could be used to manage
                dependencies and features. This functionality is now part of
                Cargo.
              </li>
              <li>
                It can be installed with
                <code>cargo install cargo-edit</code>.<br />
                See
                <a href="https://github.com/killercup/cargo-edit"
                  >https://github.com/killercup/cargo-edit</a
                >
              </li>
              <li>
                Example:

                <pre>
                  <code class="hljs bash" data-trim>
                   🦉 uggla   main  ~  workspace  rust  rand_example  1  cargo add rand -F simd_support
                      Updating crates.io index
                        Adding rand v0.8.5 to dependencies
                              Features:
                              + alloc
                              + getrandom
                              + libc
                              + packed_simd
                              + rand_chacha
                              + simd_support
                              + std
                              + std_rng
                              - log
                              - min_const_gen
                              ....
                      Locking 2 packages to latest compatible versions
                        Adding libm v0.1.4
                        Adding packed_simd_2 v0.3.8
                  </code>
                </pre>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h2>Rand</h2>
          <img src="images/rand.gif" alt="magic" width="75%" />
        </section>

        <section>
          <h3>Rand 1/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                Rand is a powerful crate for generating random numbers and
                performing random operations in Rust.
              </li>
              <li>
                It supports:
                <ul>
                  <li>Pseudo-random number generation (PRNG).</li>
                  <li>Cryptographically secure random number generation.</li>
                  <li>Shuffling and sampling.</li>
                </ul>
              </li>
              <li>
                Simple to use with:
                <ol>
                  <li>Adding the crate to your <code>Cargo.toml</code>.</li>
                  <li>Using the provided utilities in your code.</li>
                </ol>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Rand 2/3</h3>
          <div class="lots_of_items">
            <pre>
              <code class="hljs rust" data-trim>
                use rand::Rng;

                fn main() {
                    let mut rng = rand::thread_rng();
                    let x: u8 = rng.gen();
                    println!("Random u8: {}", x);

                    let y = rng.gen_range(1..101);
                    println!("Random number between 1 and 100: {}", y);
                }
              </code>
            </pre>
          </div>
        </section>

        <section>
          <h3>Rand 3/3</h3>
          <div class="lots_of_items">
            <pre>
              <code class="hljs rust" data-trim>
                use rand::seq::SliceRandom;

                fn main() {
                    let mut rng = rand::thread_rng();

                    let mut numbers = vec![1, 2, 3, 4, 5];
                    numbers.shuffle(&mut rng);
                    println!("Shuffled numbers: {:?}", numbers);

                    let choice = numbers.choose(&mut rng);
                    println!("Random choice: {:?}", choice);
                }
              </code>
            </pre>
          </div>
        </section>

        <section>
          <h3>Serde</h3>
          <img src="images/spongebob-magic.gif" alt="magic" width="75%" />
        </section>

        <section>
          <h3>Serde 1/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                Serde is a magical framework for serializing and deserializing
                Rust data structures into JSON, TOML, YAML, and more.
              </li>
              <li>
                Format supported by compagnion crates: serde_json, bincode...
              </li>
              <li>
                It is as simple as:
                <ol>
                  <li>Deriving a struct.</li>
                  <li>Converting to and from strings.</li>
                </ol>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Serde 2/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use serde::{Serialize, Deserialize};

                  #[derive(Serialize, Deserialize, Debug)]
                  struct User {
                      id: u32,
                      name: String,
                      email: String,
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Serde 3/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  fn main() {
                      // Sérialisation : Rust → JSON
                      let user = User {
                          id: 1,
                          name: "Alice".to_string(),
                          email: "alice@example.com".to_string(),
                      };
                      let json = serde_json::to_string(&user).unwrap();
                      println!("JSON: {}", json);

                      // Désérialisation : JSON → Rust
                      let json_str = r#"
                          {
                              "id": 2,
                              "name": "Bob",
                              "email": "bob@example.com"
                          }
                      "#;
                      let deserialized_user: User = serde_json::from_str(json_str).unwrap();
                      println!("User: {:?}", deserialized_user);
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Clap</h3>
          <img src="images/clap.gif" alt="clap" width="50%" />
        </section>

        <section>
          <h3>Clap 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>Already well covered in a previous meetup.</li>
              <li>Parse CLI arguments an options.</li>
              <li>
                Derive feature allow to define arguments and options from a
                struct.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Clap 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use clap::Parser;

                  /// Simple CLI tool example
                  #[derive(Parser, Debug)]
                  #[command(name = "greet")]
                  #[command(about = "A simple program to greet someone", long_about = None)]
                  struct Args {
                      /// The name of the person to greet
                      #[arg(short, long)]
                      name: String,

                      /// Number of times to print the greeting
                      #[arg(short, long, default_value_t = 1)]
                      count: u8,
                  }

                  fn main() {
                      let args = Args::parse();

                      for _ in 0..args.count {
                          println!("Hello, {}!", args.name);
                      }
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Thiserror / Anyhow</h3>
          <img src="images/error.gif" alt="error" width="50%" />
        </section>

        <section>
          <h3>Thiserror / Anyhow 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>Already well covered in a previous meetup.</li>
              <li>
                Thiserror:
                <ul>
                  <li>
                    Provides an ergonomic way to define custom error types in
                    Rust.
                  </li>
                  <li>
                    Automatically implements the
                    <code>std::error::Error</code> trait for your errors.
                  </li>
                  <li>
                    Best suited for libraries where structured error types are
                    needed.
                  </li>
                </ul>
              </li>

              <li>
                Anyhow
                <ul>
                  <li>
                    Simplifies error handling for applications (not libraries).
                  </li>
                  <li>
                    Offers a generic error type <code>anyhow::Error</code> to
                    encapsulate any error.
                  </li>
                  <li>
                    Perfect for applications that don't need precise error
                    typing.
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Thiserror / Anyhow 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use anyhow::{Context};
                  use thiserror::Error;

                  #[derive(Error, Debug)]
                  enum MyError {
                      #[error("Configuration file not found: {0}")]
                      ConfigNotFound(String),

                      #[error("Invalid input: {0}")]
                      InvalidInput(String),
                  }

                  fn read_config(file: &str) -> Result&lt;String, MyError&gt; {
                      if file == "missing.conf" {
                          return Err(MyError::ConfigNotFound(file.to_string()).into());
                      }
                      if file == "invalid.conf" {
                          return Err(MyError::InvalidInput("Invalid syntax".to_string()).into());
                      }
                      Ok("config content".to_string())
                  }

                  fn main() -> anyhow::Result&lt;()&gt;{
                      let config =
                          read_config("missing.conf").with_context(|| "Failed to load the configuration file")?;
                      println!("Config: {}", config);
                      Ok(())
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Nom</h2>
          <img src="images/om-nom.gif" alt="nom" width="50%" />
        </section>

        <section>
          <h3>Nom 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>Nom is a parser combinators library.</li>
              <li>It is like regexp on steroids and more readable.</li>
              <li>It can work on complete strings or streams.</li>
              <li>
                The regexp library is great too, but to my mind, nom help to
                write more maintainable code.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Nom 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  #[derive(Debug,PartialEq)]
                  pub struct Color { pub red:   u8, pub green: u8, pub blue:  u8, }

                  fn from_hex(input: &str) -> Result&lt;u8, std::num::ParseIntError&gt; {
                    u8::from_str_radix(input, 16)
                  }

                  fn is_hex_digit(c: char) -> bool {
                    c.is_digit(16)
                  }

                  fn hex_primary(input: &str) -> IResult&lt;&str, u8&gt; {
                    map_res(
                      take_while_m_n(2, 2, is_hex_digit),
                      from_hex
                    )(input)
                  }

                  fn hex_color(input: &str) -> IResult&lt;&str, Color&gt; {
                    let (input, _) = tag("#")(input)?;
                    let (input, (red, green, blue)) = tuple((hex_primary, hex_primary, hex_primary))(input)?;

                    Ok((input, Color { red, green, blue }))
                  }

                  #[test]
                  fn parse_color() {
                    assert_eq!(hex_color("#2F14DF"), Ok(("", Color { red: 47, green: 20, blue: 223, })));
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Rayon</h2>
          <img src="images/deathstar-rayon.gif" alt="rayon" width="75%" />
        </section>

        <section>
          <h3>Rayon 1/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>Data parallelism library.</li>
              <li>
                Provides a lot of parallel iterators for various types.
                <ul>
                  <li>Vec</li>
                  <li>Array</li>
                  <li>Ranges</li>
                  <li>Collections</li>
                  <li>...</li>
                </ul>
              </li>
              <li>
                Simply changing an iterator fror iter to par_iter can
                parallelize it.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Rayon 2/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use rayon::prelude::*;

                  /// Check if a number is prime
                  fn is_prime(n: u64) -> bool {
                      if n < 2 {
                          return false;
                      }
                      for i in 2..=((n as f64).sqrt() as u64) {
                          if n % i == 0 {
                              return false;
                          }
                      }
                      true
                  }

                  /// Generate prime numbers up to a given limit
                  fn generate_primes(limit: u64) -> Vec&lt;u64&gt; {
                      (2..=limit) // Create a range from 2 to the limit
                          .into_par_iter() // Convert to a parallel iterator using rayon
                          .filter(|&n| is_prime(n)) // Filter out non-prime numbers
                          .collect() // Collect results into a vector
                  }

                  fn main() {
                      let limit = 20_000_000; // Upper limit for prime numbers
                      let primes = generate_primes(limit);

                      println!("Found {} primes up to {}.", primes.len(), limit);
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Rayon 3/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs bash" data-trim>
                 🦉 uggla   main  ~  workspace  rust  prime  hyperfine target/release/prime_not_par target/release/prime
                Benchmark 1: target/release/prime_not_par
                  Time (mean ± σ):     13.349 s ±  0.793 s    [User: 13.276 s, System: 0.014 s]
                  Range (min … max):   12.411 s … 14.910 s    10 runs

                Benchmark 2: target/release/prime
                  Time (mean ± σ):      3.523 s ±  0.279 s    [User: 24.565 s, System: 0.062 s]
                  Range (min … max):    3.284 s …  4.236 s    10 runs

                Summary
                  target/release/prime ran
                    3.79 ± 0.38 times faster than target/release/prime_not_par
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Itertools</h2>
          <img src="images/itertools.gif" alt="itertool" width="75%" />
        </section>

        <section>
          <h3>Itertools 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                Itertools is a powerful crate providing additional iterator
                adaptors and utilities for Rust.
              </li>
              <li>
                Extends the standard Iterator with a wide range of combinators
                for advanced data processing.
              </li>
              <li>
                Sort, join, cartesian product, permutations, combinations,
                group_by, ...
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Itertools 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  #[derive(Debug,PartialEq)]
                  use itertools::Itertools;

                  fn main() {
                      let nums = vec![3, 2, 1];

                    // Sort and join elements into a string
                      let joined = nums.iter().sorted().join(",");
                      assert_eq!("1,2,3", joined);

                      // Generate all combinations of size 2
                      let combinations: Vec&ltVec&ltusize&gt&gt = nums.into_iter().combinations(2).collect();
                      assert_eq!(vec![vec![3,2], vec![3,1],vec![2,1]], combinations);

                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Minreq</h2>
          <img src="images/minreq.gif" alt="minreq" width="75%" />
        </section>

        <section>
          <h3>Minreq 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>Simple, minimal-dependency HTTP client.</li>
              <li>Lightweight.</li>
              <li>Only sync.</li>
              <li>Serde integration.</li>
              <li>TLS support.</li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Minreq 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  fn main() -> Result<(), minreq::Error> {
                      let response = minreq::post("http://httpbin.org/anything")
                          .with_body("Hello, world!")
                          .send()?;

                      // httpbin.org/anything returns the body in the json field "data":
                      let json: serde_json::Value = response.json()?;
                      assert_eq!("Hello, world!", json["data"]);

                      Ok(())
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Ordered-float</h2>
          <img src="images/ordered-float.gif" alt="ordered-float" width="75%" />
        </section>

        <section>
          <h3>Ordered-float 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>
                Floating-point numbers (<code>f32</code>, <code>f64</code>)
                cannot be directly used as keys in structures like
                <code>HashSet</code> or <code>HashMap</code>. This is because
                they do not implement necessary traits (<code>Eq</code> and
                <code>Hash</code>) due to special behaviors (e.g.,
                <code>NaN</code>).
              </li>
            </ul>

            <ul>
              <li>
                Ordered-float provides a wrapper around floating-point types,
                making them orderable and usable in collections.
              </li>
              <ul>
                <li>
                  Ensures consistent comparisons, handling edge cases like
                  <code>-0.0</code> and <code>0.0</code> as equal, and placing
                  <code>NaN</code> consistently during sorting.
                </li>
                <li>
                  Values are sorted consistently, even with edge cases like
                  <code>-0.0</code> and <code>NaN</code>.
                </li>
                <li>
                  <code>HashSet</code> ignores duplicates and treats
                  <code>-0.0</code> and <code>0.0</code> as identical.
                </li>
              </ul>
              <li>
                Solves the problem where standard floating-point numbers cannot
                be used in such structures.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Ordered-float 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use ordered_float::OrderedFloat;
                  use std::collections::HashSet;

                  fn main() {
                      // Exemple 1 : Tri de nombres flottants
                      let mut floats = vec![3.2, 1.5, 2.8, 4.1, -0.0, 0.0, f64::NAN];
                      //floats.sort_by(|a,b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal));
                      floats.sort_by_key(|&x| OrderedFloat(x)); // Tri avec OrderedFloat

                      println!("Sorted floats: {:?}", floats);

                      // Exemple 2 : Utilisation dans un HashSet
                      let mut set: HashSet&ltOrderedFloat&ltf64&gt&gt = HashSet::new();
                      set.insert(OrderedFloat(3.2));
                      set.insert(OrderedFloat(1.5));
                      set.insert(OrderedFloat(1.5)); // Duplicate, ne sera pas ajouté
                      set.insert(OrderedFloat(-0.0)); // -0.0 et 0.0 sont considérés égaux
                      set.insert(OrderedFloat(0.0));

                      println!("HashSet contains: {:?}", set);
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Indicatif</h2>
          <img src="images/indicatif.gif" alt="indicatif" width="50%" />
        </section>

        <section>
          <h3>Indicatif 1/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>Allow to create progress bars.</li>
              <li>
                It comes with various tools and utilities for formatting
                anything that indicates progress.
              </li>
              <li>Similar to tqdm in python.</li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Indicatif 2/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use std::thread;
                  use std::time::Duration;

                  use indicatif::{ProgressBar, ProgressIterator, ProgressStyle};

                  fn main() {
                      // Default styling, attempt to use Iterator::size_hint to count input size
                      for _ in (0..1000).progress() {
                          // ...
                          thread::sleep(Duration::from_millis(5));
                      }
                      // Provide explicit number of elements in iterator
                      for _ in (0..1000).progress_count(1000) {
                          // ...
                          thread::sleep(Duration::from_millis(5));
                      }
                      // Provide a custom bar style
                      let pb = ProgressBar::new(1000);
                      pb.set_style(
                          ProgressStyle::with_template(
                              "{spinner:.green} [{elapsed_precise}] [{bar:40.cyan/blue}] ({pos}/{len}, ETA {eta})",
                          )
                          .unwrap(),
                      );
                      for _ in (0..1000).progress_with(pb) {
                          // ...
                          thread::sleep(Duration::from_millis(5));
                      }
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Indicatif 3/3</h3>
          <div class="lots_of_items">
            <video width="100%" autoplay loop muted>
              <source src="images/indicatif.mp4" type="video/mp4" />
              Your browser does not support the video tag.
            </video>
          </div>
        </section>

        <section>
          <h2>Log / Simplelogger</h2>
          <img src="images/log.gif" alt="log" width="75%" />
        </section>

        <section>
          <h3>Log / Simplelogger 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>Just a logger to display formatted logs to stdout.</li>
              <li>Extremely simple to use, based on the log crate.</li>
              <li>
                However today you might use the tracing crate as a replacement.
              </li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Log / Simplelogger 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use simple_logger::SimpleLogger;

                  fn main() {
                      SimpleLogger::new().init().unwrap();

                      log::warn!("This is an example message.");
                  }
                </code>
              </pre>
            <pre>
                <code class="hljs rust" data-trim>
                  2024-01-19T17:37:07.013874956Z WARN [logging_example] This is an example message.
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Rstest</h2>
          <img src="images/rstest.gif" alt="rstest" width="75%" />
        </section>

        <section>
          <h3>Rstest 1/2</h3>
          <div class="lots_of_items">
            <ul>
              <li>A library to extend tests features.</li>
              <li>Add fixture and parametric tests.</li>
              <li>Reduce the number of tests to write without using macros.</li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Rstest 2/2</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                use rstest::rstest;

                #[rstest]
                #[case(0, 0)]
                #[case(1, 1)]
                #[case(2, 1)]
                #[case(3, 2)]
                #[case(4, 3)]
                #[case(5, 5)]
                #[case(6, 8)]
                fn fibonacci_test(#[case] input: u32,#[case] expected: u32) {
                    assert_eq!(expected, fibonacci(input))
                }

                fn fibonacci(input: u32) -> u32 {
                    match input {
                        0 => 0,
                        1 => 1,
                        n => fibonacci(n - 2) + fibonacci(n - 1)
                    }
                }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h2>Image</h2>
          <img src="images/image.gif" alt="image" width="75%" />
        </section>

        <section>
          <h3>Image 1/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>Image processing library.</li>
              <li>Support a lot of formats (png, jpeg, bmp...).</li>
              <li>Can read, write and basically manipulate images.</li>
            </ul>
          </div>
        </section>

        <section>
          <h3>Image 2/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  const IMG_WIDTH: u32 = 800;
                  const IMG_HEIGHT: u32 = 600;

                  fn main() {
                      // Image dimensions
                      let width = IMG_WIDTH;
                      let height = IMG_HEIGHT;

                      // Create image
                      let mut img = image::RgbImage::new(width, height);

                      // Number of stars
                      let num_stars = 2000;

                      // Random number generator
                      let mut rng = rand::thread_rng();

                      for _ in 0..num_stars {
                          let channel_color = rand::Rng::gen_range(&mut rng, 100..255);

                          let x = rand::Rng::gen_range(&mut rng, 0..width);
                          let y = rand::Rng::gen_range(&mut rng, 0..height);

                          img.put_pixel(
                              x,
                              y,
                              image::Rgb([channel_color, channel_color, channel_color]),
                          );
                      }

                      img.save("stars.png").unwrap();
                  }
                </code>
              </pre>
          </div>
        </section>

        <section>
          <h3>Image 3/3</h3>
          <div class="lots_of_items"></div>
          <img src="images/image.png" alt="image_produced" width="100%" />
        </section>

        <section>
          <h2>Raqote</h2>
          <img src="images/raqote.gif" alt="raqote" width="75%" />
        </section>

        <section>
          <h3>Raqote 1/3</h3>
          <div class="lots_of_items">
            <ul>
              <li>Software 2D graphics library.</li>
              <li>Used by servo as canvas backend.</li>
              <li>Features:</li>
              <ul>
                <li>path filling</li>
                <li>stroking</li>
                <li>dashing</li>
                <li>image, solid, and gradient fills</li>
                <li>rectangular and path clipping</li>
                <li>blend modes</li>
                <li>layers</li>
                <li>repeat modes for images</li>
                <li>global alpha</li>
              </ul>
            </ul>
          </div>
        </section>

        <section>
          <h3>Raqote 2/3</h3>
          <div class="lots_of_items">
            <pre>
                <code class="hljs rust" data-trim>
                  use raqote::*;
                  fn main() {
                      let mut dt = DrawTarget::new(400, 400);
                      let mut pb = PathBuilder::new();
                      pb.move_to(100., 10.);
                      pb.cubic_to(150., 40., 175., 0., 200., 10.);
                      pb.quad_to(120., 100., 80., 200.);
                      pb.quad_to(150., 180., 300., 300.);
                      pb.close();
                      let path = pb.finish();
                      let gradient = Source::new_radial_gradient(
                          Gradient {
                              stops: vec![
                                  GradientStop {
                                      position: 0.2,
                                      color: Color::new(0xff, 0, 0xff, 0),
                                  },
                                  GradientStop {
                                      position: 1.,
                                      color: Color::new(0xff, 0xff, 0, 0xff),
                                  },
                              ],
                          },
                          Point::new(150., 150.), 128., Spread::Pad,
                      );
                      dt.fill(&path, &gradient, &DrawOptions::new());
                      let _ = dt.write_png("example.png");
                  }
                </code>
            </pre>
          </div>
        </section>

        <section>
          <h3>Raqote 3/3</h3>
          <img src="images/raqote.png" alt="raqote_example" />
        </section>

        <!-- <section> -->
        <!--   <h2>Pyo3</h2> -->
        <!--   <img src="images/space_invaders.png" alt="ecs" width="75%" /> -->
        <!-- </section> -->
        <!---->
        <!-- <section> -->
        <!--   <h2>Rustls</h2> -->
        <!--   <img src="images/space_invaders.png" alt="ecs" width="75%" /> -->
        <!-- </section> -->
        <!---->
        <!-- <section> -->
        <!--   <h2>Tungstenite</h2> -->
        <!--   <img src="images/space_invaders.png" alt="ecs" width="75%" /> -->
        <!-- </section> -->

        <section>
          <h2>Blessed</h2>
          <a href="https://blessed.rs/crates"
            ><h3>https://blessed.rs/crates</h3></a
          >
        </section>

        <section>
          <h2>What are you using ?</h2>
          <img src="images/way.gif" alt="what_are_you_using" width="30%" />
        </section>

        <section>
          <h2>Thanks</h2>
          <img src="images/thanks.gif" alt="thank_you" width="50%" />
          <ul>
            <li>René Ribaud &lt;rene.ribaud@gmail.com&gt;</li>
          </ul>
        </section>
      </div>
    </div>

    <script type="module">
      import Reveal from "../reveal.js/dist/reveal.esm.js";
      import Markdown from "../reveal.js/plugin/markdown/markdown.esm.js";
      import Notes from "../reveal.js/plugin/notes/notes.esm.js";
      import Highlight from "../reveal.js/plugin/highlight/highlight.esm.js";
      import Zoom from "../reveal.js/plugin/zoom/zoom.esm.js";

      let deck = new Reveal({
        plugins: [Markdown, Notes, Highlight, Zoom],
        controls: true,
        progress: true,
        history: true,
        center: false,
        width: 960,
        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,
        // Use this to print in pdf
        // margin: 0.6,

        // Bounds for smallest/largest possible scale to apply to content
        minScale: 0.2,
        maxScale: 1.5,

        transition: "convex",
      });

      deck.initialize();
    </script>
  </body>
</html>
